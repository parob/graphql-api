from typing import List, Any, Dict, Tuple, Optional, Type, Union

# noinspection PyPackageRequirements
from graphql import (
    GraphQLSchema,
    GraphQLObjectType,
    GraphQLField,
    GraphQLString,
    is_named_type,
    ExecutionResult,
    specified_directives,
    GraphQLDirective,
    GraphQLNamedType,
    GraphQLScalarType,
)

from graphql_api import GraphQLError

from graphql_api.executor import GraphQLExecutor, GraphQLBaseExecutor
from graphql_api.middleware import GraphQLMiddleware
from graphql_api.reduce import GraphQLSchemaReducer, GraphQLFilter
from graphql_api.mapper import GraphQLTypeMapper


class GraphQLFieldContext:
    def __init__(self, meta, query=None):
        self.meta = meta
        self.query = query

    def __str__(self):
        query_str = ""
        if self.query:
            query_str = f", query: {query_str}" if self.query else ""
        return f"<Node meta: {self.meta}{query_str}>"


class GraphQLRequestContext:
    def __init__(self, args, info):
        self.args = args
        self.info = info


# Workaround to allow GraphQLScalarType to be used in typehints in Python 3.10


def call(self, *args, **kwargs):
    raise NotImplementedError()


setattr(GraphQLScalarType, "__call__", call)


# noinspection PyShadowingBuiltins
def tag_value(
    value,
    graphql_type: str,
    schema: "GraphQLAPI" = None,
    meta: Dict = None,
    directives: List = None,
    is_root_type: bool = False,
):
    if not hasattr(value, "_graphql"):
        value._graphql = True

    if not hasattr(value, "_defined_on"):
        value._defined_on = value

    if not hasattr(value, "_schemas"):
        value._schemas = {}

    if hasattr(value, "_schemas"):
        # noinspection PyProtectedMember
        value._schemas[schema] = {
            "defined_on": value,
            "meta": meta or {},
            "graphql_type": graphql_type,
            "schema": schema,
        }

    from graphql_api.schema import add_schema_directives

    add_schema_directives(value, directives)

    if is_root_type:
        if graphql_type != "object":
            raise TypeError(f"Cannot set '{value}' of type '{graphql_type}' as a root.")

        if schema:
            schema.set_root_type(value)

    return value


# noinspection PyShadowingBuiltins
def build_decorator(
    a,
    b,
    graphql_type,
    mutable=None,
    interface=None,
    abstract=None,
    directives: List = None,
    is_root_type: bool = False,
):
    if graphql_type == "object":
        if interface:
            graphql_type = "interface"
        elif abstract:
            graphql_type = "abstract"

    if graphql_type == "field":
        if mutable:
            graphql_type = "mutable_field"

    func = a if callable(a) else b if callable(b) else None
    meta = a if isinstance(a, dict) else b if isinstance(b, dict) else None
    schema = (
        a if isinstance(a, GraphQLAPI) else b if isinstance(b, GraphQLAPI) else None
    )

    if func:
        return tag_value(
            value=func,
            graphql_type=graphql_type,
            schema=schema,
            meta=meta,
            directives=directives,
            is_root_type=is_root_type,
        )

    return lambda f: tag_value(
        value=f,
        graphql_type=graphql_type,
        schema=schema,
        meta=meta,
        directives=directives,
        is_root_type=is_root_type,
    )


class GraphQLRootTypeDelegate:
    infer_subclass_fields = True

    @classmethod
    def validate_graphql_schema(cls, schema: GraphQLSchema) -> GraphQLSchema:
        """
        This method is called whenever a schema is created with this
        class as the root type.
        :param schema: The GraphQL schema that is generated by
        :return:schema: The validated and updated GraphQL schema.
        """
        return schema


class GraphQLAPI(GraphQLBaseExecutor):
    def field(self=None, meta=None, mutable=False, directives: List = None):
        return build_decorator(
            self, meta, graphql_type="field", mutable=mutable, directives=directives
        )

    def type(
        self=None,
        meta=None,
        abstract=False,
        interface=False,
        is_root_type=False,
        directives: List = None,
    ):
        return build_decorator(
            self,
            meta,
            graphql_type="object",
            abstract=abstract,
            interface=interface,
            directives=directives,
            is_root_type=is_root_type,
        )

    def set_root_type(self, root_type):
        self.root_type = root_type
        return root_type

    def __init__(
        self,
        root_type=None,
        middleware: List[GraphQLMiddleware] = None,
        directives: List[GraphQLDirective] = None,
        types: List[Union[GraphQLNamedType, Type]] = None,
        filters: List[GraphQLFilter] = None,
        error_protection: bool = True,
        ignore_middleware_during_introspection: bool = True,
        federation: bool = False,
    ):
        super().__init__()
        if middleware is None:
            middleware = []

        if directives is None:
            directives = []

        self.root_type = root_type
        self.middleware = middleware
        self.directives = [*specified_directives] + (directives or [])
        self.types = set(types or [])
        self.filters = filters
        self.query_mapper: Optional[GraphQLTypeMapper] = None
        self.mutation_mapper: Optional[GraphQLTypeMapper] = None
        self.error_protection = error_protection
        self.ignore_middleware_during_introspection = (
            ignore_middleware_during_introspection
        )
        self.federation = federation
        self._cached_graphql_schema = None

        if self.federation:
            from graphql_api.federation.federation import apply_federation_api
            apply_federation_api(self)

    def graphql_schema(self, ignore_cache: bool = False) -> Tuple[GraphQLSchema, Dict]:
        if not ignore_cache and self._cached_graphql_schema:
            return self._cached_graphql_schema

        meta = {}

        query = None
        mutation = None
        types = None

        if self.root_type:
            # Create the root query
            query_mapper = GraphQLTypeMapper(schema=self)
            _query = query_mapper.map(self.root_type)

            for type_ in list(self.types):
                if not is_named_type(type_):
                    query_mapper.map(type_)

            if not isinstance(_query, GraphQLObjectType):
                raise GraphQLError(f"Query {_query} was not a valid ObjectType.")

            # Filter the root query
            filtered_query = GraphQLSchemaReducer.reduce_query(
                query_mapper, _query, filters=self.filters
            )

            if query_mapper.validate(filtered_query, evaluate=True):
                query = filtered_query
                query_types = query_mapper.types()
                registry = query_mapper.registry

            else:
                query_types = set()
                registry = None

            # Create the root mutation
            mutation_mapper = GraphQLTypeMapper(
                as_mutable=True, suffix="Mutable", registry=registry, schema=self
            )
            _mutation = mutation_mapper.map(self.root_type)

            if not isinstance(_mutation, GraphQLObjectType):
                raise GraphQLError(f"Mutation {_mutation} was not a valid ObjectType.")

            # Filter the root mutation
            filtered_mutation = GraphQLSchemaReducer.reduce_mutation(
                mutation_mapper, _mutation
            )

            if mutation_mapper.validate(filtered_mutation, evaluate=True):
                mutation = filtered_mutation
                mutation_types = mutation_mapper.types()
            else:
                mutation = None
                mutation_types = set()

            types = [
                type_
                for type_ in list(query_types | mutation_types | self.types)
                if is_named_type(type_)
            ]

            meta = {**query_mapper.meta, **mutation_mapper.meta}

            self.query_mapper = query_mapper
            self.mutation_mapper = mutation_mapper

        # Create a placeholder query (every GraphQL schema must have a query)
        if not query:
            query = GraphQLObjectType(
                name="PlaceholderQuery",
                fields={
                    "placeholder": GraphQLField(
                        type_=GraphQLString, resolve=lambda *_: ""
                    )
                },
            )

        for _, _, located_schema_directives in (
            self.query_mapper.located_schema_directives
            + self.mutation_mapper.located_schema_directives
        ):
            self.directives += [d.directive for d in located_schema_directives]

        schema = GraphQLSchema(
            query=query, mutation=mutation, types=types, directives=self.directives
        )

        if self.root_type and issubclass(self.root_type, GraphQLRootTypeDelegate):
            schema = self.root_type.validate_graphql_schema(schema)

        self._cached_graphql_schema = schema, meta
        if self.federation:
            from graphql_api.federation.federation import apply_federation_schema
            schema = apply_federation_schema(self, schema)

        return schema, meta

    def execute(
        self,
        query,
        variables=None,
        operation_name=None,
        root_value: Any = None,
    ) -> ExecutionResult:
        return self.executor(root_value=root_value).execute(
            query=query,
            variables=variables,
            operation_name=operation_name,
        )

    def executor(
        self,
        root_value: Any = None,
    ) -> GraphQLExecutor:
        schema, meta = self.graphql_schema()

        if callable(self.root_type) and root_value is None:
            root_value = self.root_type()

        ignore_middleware = self.ignore_middleware_during_introspection

        return GraphQLExecutor(
            schema=schema,
            meta=meta,
            root_value=root_value,
            middleware=self.middleware,
            ignore_middleware_during_introspection=ignore_middleware,
            error_protection=self.error_protection,
        )
