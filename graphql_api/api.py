from typing import List, Callable, Any, Type, Dict, Tuple

# noinspection PyPackageRequirements
from graphql import (
    GraphQLSchema,
    GraphQLObjectType,
    GraphQLField,
    GraphQLString,
    is_named_type,
    ExecutionResult,
    GraphQLType, specified_directives, GraphQLDirective,
)

from graphql_api import GraphQLError

from graphql_api.executor import GraphQLExecutor, GraphQLBaseExecutor
from graphql_api.context import GraphQLContext
from graphql_api.reduce import GraphQLSchemaReducer, GraphQLFilter
from graphql_api.mapper import GraphQLTypeMapper


class GraphQLFieldContext:
    def __init__(self, meta, query=None):
        self.meta = meta
        self.query = query

    def __str__(self):
        query_str = ""
        if self.query:
            query_str = f", query: {query_str}" if self.query else ""
        return f"<Node meta: {self.meta}{query_str}>"


class GraphQLRequestContext:
    def __init__(self, args, info):
        self.args = args
        self.info = info


# noinspection PyShadowingBuiltins
def decorate(
    func: Callable,
    type: str,
    schema: "GraphQLAPI" = None,
    meta: Dict = None,
    directives: List = None,
    root: bool = False
):
    func._graphql = True
    func._defined_on = func
    func._directives = directives

    if not meta:
        meta = {}

    if not hasattr(func, "_schemas"):
        func._schemas = {}

    if hasattr(func, "_schemas"):
        # noinspection PyProtectedMember
        func._schemas[schema] = {
            "defined_on": func,
            "meta": meta,
            "type": type,
            "schema": schema
        }
    meta["directives"] = directives

    if schema and directives:
        schema.directives.update(directives)

    if root and schema:
        schema.set_root(func)

    return func


# noinspection PyShadowingBuiltins
def decorator(a, b, type, directives, root=None):
    func = a if callable(a) else b if callable(b) else None
    meta = a if isinstance(a, dict) else b if isinstance(b, dict) else None
    schema = a if isinstance(a, GraphQLAPI) else b if isinstance(b, GraphQLAPI) else None

    if func:
        return decorate(func=func, type=type, schema=schema, meta=meta, directives=directives, root=root)

    def _decorate(_func):
        return decorate(func=_func, type=type, schema=schema, meta=meta, directives=directives, root=root)
    return _decorate


class GraphQLRootTypeDelegate:
    infer_subclass_fields = True

    @classmethod
    def validate_graphql_schema(cls, schema: GraphQLSchema) -> GraphQLSchema:
        """
        This method is called whenever a schema is created with this
        class as the root type.
        :param schema: The GraphQL schema that is generated by
        :return:schema: The validated and updated GraphQL schema.
        """
        return schema


class GraphQLAPI(GraphQLBaseExecutor):
    def field(self=None, meta=None, mutable=False, directives: List = None):
        _type = "query"
        if mutable:
            _type = "mutation"

        return decorator(self, meta, type=_type, directives=directives)

    def type(self=None, meta=None, abstract=False, interface=False, root=False, directives: List = None):
        _type = "object"
        if interface:
            _type = "interface"
        elif abstract:
            _type = "abstract"

        return decorator(self, meta, type=_type, directives=directives, root=root)

    def set_root(self, root_type):
        self.root_type = root_type
        return root_type

    def __init__(
        self,
        root: Type = None,
        middleware: List[Callable[[Callable, GraphQLContext], Any]] = None,
        directives: List[GraphQLDirective] = None,
        filters: List[GraphQLFilter] = None,
        error_protection=True,
    ):
        super().__init__()
        if middleware is None:
            middleware = []

        if directives is None:
            directives = []

        self.root_type = root
        self.middleware = middleware
        self.directives = {
            directive.name: directive
            for directive in [*specified_directives, *directives]
        }
        self.filters = filters
        self.query_mapper = None
        self.mutation_mapper = None
        self.error_protection = error_protection

    def graphql_schema(self) -> Tuple[GraphQLSchema, Dict]:
        schema_args = {}
        meta = {}

        if self.root_type:
            # Create the root query
            query_mapper = GraphQLTypeMapper(schema=self)
            query: GraphQLType = query_mapper.map(self.root_type)

            if not isinstance(query, GraphQLObjectType):
                raise GraphQLError(f"Query {query} was not a valid ObjectType.")

            # Filter the root query
            filtered_query = GraphQLSchemaReducer.reduce_query(
                query_mapper, query, filters=self.filters
            )

            if query_mapper.validate(filtered_query, evaluate=True):
                schema_args["query"] = filtered_query
                query_types = query_mapper.types()
                registry = query_mapper.registry

            else:
                query_types = set()
                registry = None

            # Create the root mutation
            mutation_mapper = GraphQLTypeMapper(
                as_mutable=True, suffix="Mutable", registry=registry, schema=self
            )
            mutation: GraphQLType = mutation_mapper.map(self.root_type)

            if not isinstance(mutation, GraphQLObjectType):
                raise GraphQLError(f"Mutation {mutation} was not a valid ObjectType.")

            # Filter the root mutation
            filtered_mutation = GraphQLSchemaReducer.reduce_mutation(
                mutation_mapper, mutation
            )

            if mutation_mapper.validate(filtered_mutation, evaluate=True):
                schema_args["mutation"] = filtered_mutation
                mutation_types = mutation_mapper.types()
            else:
                mutation_types = set()

            schema_args["types"] = list(query_types | mutation_types)
            schema_args["types"] = [
                type_ for type_ in schema_args["types"] if is_named_type(type_)
            ]

            meta = {**query_mapper.meta, **mutation_mapper.meta}

            self.query_mapper = query_mapper
            self.mutation_mapper = mutation_mapper

        # Create a placeholder query (every GraphQL schema must have a query)
        if "query" not in schema_args:
            placeholder = GraphQLField(type_=GraphQLString, resolve=lambda *_: "")
            schema_args["query"] = GraphQLObjectType(
                name="PlaceholderQuery", fields={"placeholder": placeholder}
            )
        schema_args["directives"] = self.directives.values()

        schema = GraphQLSchema(**schema_args)

        if self.root_type and issubclass(self.root_type, GraphQLRootTypeDelegate):
            schema = self.root_type.validate_graphql_schema(schema)

        return schema, meta

    def execute(
        self,
        query,
        variables=None,
        operation_name=None,
        root_value: Any = None,
        middleware: List[Callable[[Callable, GraphQLContext], Any]] = None,
        middleware_on_introspection: bool = False,
        error_protection: bool = None,
    ) -> ExecutionResult:
        return self.executor(
            root_value=root_value,
            middleware=middleware,
            middleware_on_introspection=middleware_on_introspection,
            error_protection=error_protection,
        ).execute(
            query=query,
            variables=variables,
            operation_name=operation_name,
        )

    def executor(
        self,
        root_value: Any = None,
        middleware: List[Callable[[Callable, GraphQLContext], Any]] = None,
        middleware_on_introspection: bool = False,
        error_protection: bool = None,
    ) -> GraphQLExecutor:
        schema, meta = self.graphql_schema()

        if callable(self.root_type) and root_value is None:
            root_value = self.root_type()

        return GraphQLExecutor(
            schema=schema,
            meta=meta,
            root_value=root_value,
            middleware=middleware,
            middleware_on_introspection=middleware_on_introspection,
            error_protection=error_protection
            if error_protection is not None
            else self.error_protection,
        )
